const r=["_query","_fragment"];class e{constructor(r,e,t,s,i,o,n){this.setName(r),this.setUri(e),this.methods=t||[],this.parameters=s||[],this.bindings=i||{},this.setParameters(o||{}),this.config=n||{},this.setUrl(this.config.url),this.missingParameters=[]}setName(r){if("string"!=typeof r)throw new TypeError("The name parameter must be a string");this.name=r}setUri(r){if("string"!=typeof r)throw new TypeError("The uri parameter must be a string");this.uri="/"===r?"":r}setUrl(r){if("string"!=typeof r)throw new TypeError("The url parameter must be a string");this.url=new URL(r)}setParameters(e){if("object"!=typeof e)throw new TypeError("The parameters parameter must be an object");const t=e||{},{_query:s,_fragment:i}=t,o=function(r,e){if(null==r)return{};var t={};for(var s in r)if({}.hasOwnProperty.call(r,s)){if(e.includes(s))continue;t[s]=r[s]}return t}(t,r);this.queryParameters=s||{},this.fragment=i||null,this.incomingParameters=o||{}}getBinding(r){return this.bindings[r]||null}resolveRouteParameters(r){if("string"!=typeof r)throw new TypeError("The uri parameter must be a string");return Object.entries(this.config.defaults).forEach(([e,t])=>{if("object"!=typeof t)r=r.replace(`{${e}}`,t.toString());else{const s=this.getBinding(e);if(!s)return;r=r.replace(`{${e}}`,t[s].toString())}}),Object.entries(this.incomingParameters).forEach(([e,t])=>{if(this.parameters.includes(e)||this.config.defaults.hasOwnProperty(e))if("object"!=typeof t)r=r.replace(`{${e}}`,t.toString());else{let s=this.getBinding(e);if(!s)throw new Error(`Plum error: route '${this.name}' has no binding for parameter '${e}'.`);r=r.replace(`{${e}}`,t[s].toString())}else this.missingParameters.push(e)}),r}convertQueryParameters(r){const e={boolean:r=>r?1:0}[typeof r];return e?e(r):r}resolveMissingParameters(r){if("object"!=typeof r)throw new TypeError("The url parameter must be an object");return this.missingParameters.length<1||this.missingParameters.forEach(e=>{const t=this.incomingParameters[e];if("object"==typeof t)throw new Error(`Plum error: missing parameter '${e}' has an invalid value.`);r.searchParams.append(e,this.convertQueryParameters(t).toString())}),r}resolveQueryParameters(r){if("object"!=typeof r)throw new TypeError("The url parameter must be an object");return Object.entries(this.queryParameters).forEach(([e,t])=>{if("object"==typeof t)throw new Error(`Plum error: missing parameter '${e}' has an invalid value`);r.searchParams.append(e,this.convertQueryParameters(t).toString())}),r}resolveFragment(r){return this.fragment?(r.hash=this.fragment,r):r}compile(){return this.url.pathname=this.resolveRouteParameters(this.uri),this.url=this.resolveMissingParameters(this.url),this.url=this.resolveQueryParameters(this.url),this.url=this.resolveFragment(this.url),this.compiled=!0,this}toString(){if(!this.compiled)throw new Error(`Plum error: route '${this.name}' is not compiled`);return this.config.absolute?this.url.href:this.url.pathname+this.url.search+this.url.hash}}class t{constructor(r,e,t,s){this.setUrl(r),this.setPort(e),this.defaults=t||{},this.routes=s||{}}setUrl(r){if("string"!=typeof r)throw new TypeError("The url parameter must be a string");this.url=r}setPort(r){if("number"!=typeof r)throw new TypeError("The port parameter must be a number");this.port=r}has(r){return this.routes.hasOwnProperty(r)}fetchRoute(r,t={},s=!0){if(!this.has(r))throw new Error(`Plum error: route '${r}' is not in the route list.`);const i=this.routes[r];return new e(r,i.uri,i.methods,i.parameters,i.bindings,t,{url:this.url,port:this.port,defaults:this.defaults,absolute:s})}}function s(r,e={},s=!0){const i=("undefined"!=typeof plum?plum:globalThis.plum)||null;if("object"!=typeof i)throw new Error("Unable to find Plum");const o=new t(i.url,parseInt(i.port),i.defaults,i.routes);return r||e||s?o.fetchRoute(r,e,s).compile().toString():{has:r=>o.has(r)}}const i={install(r){function e(r,e,t){return s(r,e,t)}r.config.globalProperties.route=e,r.provide("route",e)}};export{i as PlumVue,s as route};
